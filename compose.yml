networks:
  backend:

secrets:
  postgres_password:
    file: secrets/postgres/postgres_password
  synapse_signing_key:
    file: secrets/synapse/signing.key
  livekit_api_key:
    file: secrets/livekit/livekit_api_key
  livekit_secret_key:
    file: secrets/livekit/livekit_secret_key

services:
  generate-synapse-secrets:
    image: ghcr.io/element-hq/synapse:latest
    user: $USER_ID:$GROUP_ID
    restart: "no"
    volumes:
      - ${VOLUME_PATH}/data/synapse:/data:rw
      - ${VOLUME_PATH}/init/generate-synapse-secrets.sh:/entrypoint.sh
    env_file: .env
    environment:
      SYNAPSE_CONFIG_DIR: /data
      SYNAPSE_CONFIG_PATH: /data/homeserver.yaml.default
      SYNAPSE_SERVER_NAME: ${DOMAIN}
      SYNAPSE_REPORT_STATS: ${REPORT_STATS}
    entrypoint: "/entrypoint.sh"
  postgres:
    image: postgres:latest
    restart: unless-stopped
    volumes:
      - ${VOLUME_PATH}/data/postgres:/var/lib/postgresql/data:rw
      - ${VOLUME_PATH}/scripts/create-multiple-postgresql-databases.sh:/docker-entrypoint-initdb.d/create-multiple-postgresql-databases.sh
    networks:
      - backend
    environment:
      POSTGRES_MULTIPLE_DATABASES: synapse,mas
      POSTGRES_USER: matrix # FIXME: use different username+passwords for synapse & MAS DBs.
      POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
      POSTGRES_INITDB_ARGS: --encoding=UTF8 --locale=C
      PGDATA: /var/lib/postgresql/data/data # otherwise it clashes with .gitkeep in the parent dir
    secrets:
      - postgres_password
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U matrix"]
      start_period: "1s"
      interval: "1s"
      timeout: "5s"
    depends_on:
      init:
        condition: service_completed_successfully

  init:
    build: init
    user: $USER_ID:$GROUP_ID
    restart: "no"
    volumes:
      - ${VOLUME_PATH}/secrets:/secrets
      - ${VOLUME_PATH}/data:/data
      - ${VOLUME_PATH}/data-template:/data-template
      - ${VOLUME_PATH}/init/init.sh:/init.sh
      - ${VOLUME_PATH}/init/mail.sh:/mail.sh
    command: "/init.sh"
    env_file: .env
    depends_on:
      generate-synapse-secrets:
        condition: service_completed_successfully
  redis:
    image: redis:latest
    restart: unless-stopped
    # healthcheck:
    #   test: ["CMD-SHELL", "redis-cli ping | grep PONG"]
    #   interval: 1s
    #   timeout: 3s
    #   retries: 5
    networks:
      - backend
  
  synapse:
    image: ghcr.io/element-hq/synapse:latest
    user: $USER_ID:$GROUP_ID
    restart: unless-stopped
    volumes:
      - ${VOLUME_PATH}/data/synapse:/data:rw
    ports:
      - 8008:8008
    networks:
      - backend
    environment:
      SYNAPSE_CONFIG_DIR: /data
      SYNAPSE_CONFIG_PATH: /data/homeserver.yaml
    secrets:
      - synapse_signing_key
    depends_on:
      postgres:
        condition: service_healthy
      init:
        condition: service_completed_successfully
  
  synapse-admin:
    image: ghcr.io/etkecc/synapse-admin:latest
    ports:
      - "8009:80"
    restart: unless-stopped
    volumes:
      - ${VOLUME_PATH}/data/synapse-admin/config.json:/app/config.json
    depends_on:
      synapse:
        condition: service_healthy
      init:
        condition: service_completed_successfully
  element-web:
    image: vectorim/element-web:latest
    restart: unless-stopped
    ports:
      - 8010:80
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O /dev/null http://localhost:80/version || exit 1"]
      start_period: "5s"
      interval: "15s"
      timeout: "5s"
    networks:
      - backend
    volumes:
      - ${VOLUME_PATH}/data/element-web/config.json:/app/config.json
    depends_on:
      init:
        condition: service_completed_successfully
  livekit:
    image: livekit/livekit-server:latest
    restart: unless-stopped
    volumes:
      - ${VOLUME_PATH}/data/livekit/config.yaml:/etc/livekit.yaml
    command: --config /etc/livekit.yaml --node-ip ${LIVEKIT_NODE_IP}
    ports:
      - 7880:7880 # HTTP listener
      # - 7881:7881 # TCP WebRTC transport, advertised via SDP
      - 7882:7882/udp
      - 7883:7883/udp
      - 7884:7884/udp
      - 7885:7885/udp

      # TODO: expose livekit-turn on TCP & UDP 443 via nginx
      # At least this would allow UDP turn on port 443 for better perf.

      # You can't expose a massive range here as it literally sets up 10,000 userland listeners, which takes forever
      # and will clash with any existing high-numbered ports.
      # So for now, tunnel everything via TCP 7881. FIXME!
      #- 50000-60000:50000-60000/tcp # TCP media
      #- 50000-60000:50000-60000/udp # UDP media
    networks:
      - backend
    depends_on:
      init:
        condition: service_completed_successfully
      redis:
        condition: service_started

  livekit-jwt-service:
    image: ghcr.io/element-hq/lk-jwt-service:latest
    restart: unless-stopped
    ports:
      - 8011:8080
    env_file: .env
    environment:
      - LIVEKIT_JWT_PORT=8080
      - LIVEKIT_URL=https://${LIVEKIT_FQDN}
      - LIVEKIT_KEY_FROM_FILE=/run/secrets/livekit_api_key
      - LIVEKIT_SECRET_FROM_FILE=/run/secrets/livekit_secret_key
    deploy:
      restart_policy:
        condition: on-failure
    networks:
      - backend
    secrets:
      - livekit_api_key
      - livekit_secret_key
    depends_on:
      init:
        condition: service_completed_successfully
      livekit:
        condition: service_started
  element-call:
    image: ghcr.io/element-hq/element-call:latest-ci
    restart: unless-stopped
    ports:
      - 8012:80
    networks:
      - backend
    volumes:
      - ${VOLUME_PATH}/data/element-call/config.json:/app/config.json
    depends_on:
      init:
        condition: service_completed_successfully